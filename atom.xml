<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chasonhuang.github.io</id>
    <title>驯鹿者</title>
    <updated>2020-07-23T02:22:42.256Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chasonhuang.github.io"/>
    <link rel="self" href="https://chasonhuang.github.io/atom.xml"/>
    <subtitle>微笑不失礼</subtitle>
    <logo>https://chasonhuang.github.io/images/avatar.png</logo>
    <icon>https://chasonhuang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 驯鹿者</rights>
    <entry>
        <title type="html"><![CDATA[设计模式之适配器模式]]></title>
        <id>https://chasonhuang.github.io/post/she-ji-mo-shi-zhi-gua-pei-qi-mo-shi/</id>
        <link href="https://chasonhuang.github.io/post/she-ji-mo-shi-zhi-gua-pei-qi-mo-shi/">
        </link>
        <updated>2020-07-22T11:00:14.000Z</updated>
        <content type="html"><![CDATA[<p>适配器模式适配器模式: 一般是指不兼容的方法调用之间的一个代码薄层。<br>
分为类适配器和对象适配器，但是类适配器一般要多继承，所以不推荐使用。实际场景<br>
我们在旧的系统中实现一个需要传入三个参数的方法，并且已经有很多地方在使用这个方法。现在有一个新的系统也想使用这个方法，但是它只能提供将三个参数合并为一个数组的参数。<br>
这时我们需要一个代码薄层将数据进行转化，使两个系统完成对接。适配器模式的结构<br>
*<br>
原有的系统的接口<br>
*<br>
适配器类实现原系统接口</p>
<p>interface Graph {<br>
drawLine();</p>
<p>drawPie();<br>
}</p>
<p>class Canvas2D implements Graph {<br>
drawLine() {<br>
console.log(&quot;draw 2d line&quot;);<br>
}</p>
<p>drawPie() {<br>
console.log(&quot;draw 2d pie&quot;);<br>
}<br>
}</p>
<p>class Canvas3D {<br>
draw3DLine() {<br>
console.log(&quot;draw 3d line&quot;);<br>
}</p>
<p>draw3DPie() {<br>
console.log(&quot;draw 3d pie&quot;);<br>
}<br>
}</p>
<p>class Canvas3DAdapter implements Graph {<br>
private canvas3D: Canvas3D = new Canvas3D();</p>
<p>drawLine() {<br>
this.canvas3D.draw3DLine();<br>
}</p>
<p>drawPie() {<br>
this.canvas3D.draw3DPie();<br>
}<br>
}</p>
<p>let canvas2D: Graph = new Canvas2D();<br>
canvas2D.drawLine();<br>
canvas2D.drawPie();</p>
<p>let canvas3D: Graph = new Canvas3DAdapter();<br>
canvas3D.drawLine();<br>
canvas3D.drawPie();</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式之工厂模式]]></title>
        <id>https://chasonhuang.github.io/post/she-ji-mo-shi-zhi-gong-han-mo-shi/</id>
        <link href="https://chasonhuang.github.io/post/she-ji-mo-shi-zhi-gong-han-mo-shi/">
        </link>
        <updated>2020-07-22T10:58:35.000Z</updated>
        <content type="html"><![CDATA[<p>概念：（不需要new）　　工厂模式的定义：提供创建对象的接口，意思就是根据领导（调用者）的指示（参数），生产相应的产品（对象）。      创建一个对象常常需要复杂的过程，所以不适合在一个复杂的对象中。　　创建对象可能会导致大量的重复代码，也可能提供不了足够级别的抽象。      工厂就是把成员对象的创建工作转交给一个外部对象，好处在于消除对象之间的耦合(也就是相互影响) 分类： 　  简单工厂模式：使用一个类，通常为单体，来生成实例。　　复杂工厂模式定义是：将其成员对象的实列化推到子类中，子类可以重写父类接口方法以便创建的时候指定自己的对象类型。 　　父类只对创建过程中的一般性问题进行处理，这些处理会被子类继承，子类之间是相互独立的，具体的业务逻辑会放在子类中进行编写。简单工厂目的设计一个创建对象的方法，让派生类控制对象创建的过程。何时使用<br>
1. 不知道要创建的具体类<br>
2. 派生类指定具体的创建过程和细节<br>
3. 父类希望延迟创建到派生类</p>
<p>举例很多系统都有用户和用户组的概念，比如linux系统，当系统想创建一个用户的时候，系统会把创建的工作交给各个具体的用户实现类。父类会处理所有的公共操作，派生类则会定一个工厂方法来处理特殊的操作。系统可能又AdminUser和StandardUser，但是他们都派生于UserObject。AdminUser在创建的时候可能会做一些额外的操作确保自己的权限比较大。<br>
GunType {AK,M4A1}interface Shootable {shoot: () =&gt; void;}abstract class Gun implements Shootable {// 抽象产品 - 枪public abstract shoot(): void;}class AK47 extends Gun {//具体产品 - AK47shoot() {console.log(&quot;ak47 shoot.&quot;);}}class M4A1 extends Gun {//具体产品 - M4A1shoot() {console.log(&quot;m4a1 shoot.&quot;);}}class GunFactory {static createGun(type: GunType): Gun {switch (type) {case GunType.AK:return new AK47();case GunType.M4A1:return new M4A1();default:throw Error(&quot;not support this gun yet&quot;);}}}GunFactory.createGun(GunType.AK).shoot();GunFactory.createGun(GunType.M4A1).shoot();抽象工厂目的提供接口创建系列产品何时使用<br>
1. 创建的对象和使用它们的系统是分离的<br>
2. 需要创建的对象是家族式的<br>
3. 创建的众多对象是在一起使用的<br>
4. 具体创建对象的类和系统解耦</p>
<p>举例在游戏中往往需要创建大量对象，下面的代码需要创建巫师和剑士，他们自己分别又包含很多对象。const factoryType = {swordsman: &quot;swordsman&quot;,wizard: &quot;wizard&quot;};class IHeroFactory {createAbilities() {}createEquipment() {}createSkills() {}}class SwordsmanFactory extends IHeroFactory {createAbilities() {return new SwordsmanAbility();}createEquipment() {return new SwordsmanEquipment();}createSkills() {return new SwordsmanSkill();}}class WizardFactory extends IHeroFactory {createAbilities() {return new WizardAbilitiy();}createEquipment() {return new WizardEquipment();}createSkills() {return new WizardSkill();}}class FactoryMaker {static getHeroFactory(type) {var factory = null;switch (type) {case factoryType.wizard:factory = new WizardFactory();break;case factoryType.swordsman:factory = new SwordsmanFactory();break;}return factory;}}class IAbstractSkill {getMainSkill() {}getSecondarySkill() {}}class SwordsmanSkill extends IAbstractSkill {public _mainSkillName: string;public _secondarySkillType: string;constructor() {super();this._mainSkillName = &quot;slash&quot;;this._secondarySkillType = &quot;berserk&quot;;}getMainSkill() {return this._mainSkillName;}getSecondarySkill() {return this._secondarySkillType;}}class WizardSkill extends IAbstractSkill {public _mainSkillName: string;public _secondarySkillType: string;constructor() {super();this._mainSkillName = &quot;fireball&quot;;this._secondarySkillType = &quot;tornado&quot;;}getMainSkill() {return this._mainSkillName;}getSecondarySkill() {return this._secondarySkillType;}}class IAbstractEquipment {getEquipment() {}}class SwordsmanEquipment extends IAbstractEquipment {public _equipment: {};constructor() {super();this._equipment = {type: &quot;Robe of the Chaos&quot;,armor: 20,resistance: 100};}getEquipment() {return this._equipment;}}class WizardEquipment extends IAbstractEquipment {public _equipment: {};constructor() {super();this._equipment = {type: &quot;Wrath of the Lich King&quot;,armor: 3,extraIntelligence: 5,extraMP: 100};}getEquipment() {return this._equipment;}}class IAbstractAbility {getAbilities() {}}class SwordsmanAbility extends IAbstractAbility {public _heroProperties: {};constructor() {super();this._heroProperties = {strength: 10,agility: 5,extraPower: true,extraPowerLevel: 1};}getAbilities() {return this._heroProperties;}}class WizardAbilitiy extends IAbstractAbility {public _heroProperties: {};constructor() {super();this._heroProperties = {strength: 10,intelligence: 30,agility: 5};}getAbilities() {return this._heroProperties;}}(function run() {let wizardFactory = FactoryMaker.getHeroFactory(factoryType.wizard),swordsmanFactory = FactoryMaker.getHeroFactory(factoryType.swordsman);let wiz = {abilities: wizardFactory.createAbilities(),equipment: wizardFactory.createEquipment(),skills: wizardFactory.createSkills()};let swrd = {abilities: swordsmanFactory.createAbilities(),equipment: swordsmanFactory.createEquipment(),skills: swordsmanFactory.createSkills()};let testHero = {abilities: wizardFactory.createAbilities(),equipment: wizardFactory.createEquipment(),skills: swordsmanFactory.createSkills()};console.log(wiz, swrd, testHero);})();</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式之观察者模式]]></title>
        <id>https://chasonhuang.github.io/post/she-ji-mo-shi-zhi-guan-cha-zhe-mo-shi/</id>
        <link href="https://chasonhuang.github.io/post/she-ji-mo-shi-zhi-guan-cha-zhe-mo-shi/">
        </link>
        <updated>2020-07-22T10:58:02.000Z</updated>
        <content type="html"><![CDATA[<p>简介<br>
观察者模式又叫发布订阅模式，他定义了一种一对多的关系，让多个观察者对象同时监听某一个主体对象，这个主体对象发生改变时就会通知所有观察者，使得他们能够自动更新自己</p>
<p>提供一种抽象的策略，以便订阅者能供彼此独立的应对改变</p>
<p>优点<br>
可以被广泛的应用到异步编程中，是一种代替传统回调函数的方案</p>
<p>可以取代对象之间硬编码的通知机制，一个对象不再显示的调用另外一个对象的某个接口，发布订阅模式让两个对象松耦合的联系在一起，虽然不太清楚彼此的细节，但这不影响他们之间相互通信。有新的订阅者出现时，发布者的代码不需要任何的修改，同样发布者的需求改变时，也不会影响到之前的订阅者，只要约定的事件没有变化，就可以自由的改变他们</p>
<p>实现步骤<br>
指定发布者<br>
给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者<br>
最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里边的回调函数</p>
<p>// 发布类<br>
class Subject {<br>
// 缓存列表，用以存放回调函数，以便通知订阅者<br>
private observers: Observer[] = new Array<Observer>();<br>
private state: number;</p>
<p>// 新增订阅者<br>
public subscribe(observer: Observer): void {<br>
this.observers.push(observer);<br>
}</p>
<p>// 改变状态，通知订阅者<br>
public setState(state: number): void {<br>
console.log(<code>Warning: State changed: ${state}</code>);<br>
this.state = state;<br>
this.publish();<br>
}</p>
<p>// 获取状态<br>
public getState(): number {<br>
return this.state;<br>
}</p>
<p>// 发布事件<br>
public publish(): void {<br>
for (let observer of this.observers) {<br>
observer.update();<br>
}<br>
}</p>
<p>// 取消订阅<br>
public unsubscribe(observer?: Observer): void {<br>
// 如果没传参数，则清空订阅者<br>
if (!observer) {<br>
this.observers = new Array<Observer>();<br>
} else {<br>
this.observers.splice(this.observers.indexOf(observer), 1);<br>
}<br>
}<br>
}</p>
<p>// 订阅者抽象类<br>
abstract class Observer {<br>
// 订阅的内容<br>
protected subject: Subject;</p>
<p>// 订阅更新<br>
public abstract update(): void;<br>
}</p>
<p>class AObserver extends Observer {<br>
// 构造方法里订阅<br>
public constructor(subject: Subject) {<br>
super();<br>
this.subject = subject;<br>
this.subject.subscribe(this);<br>
}</p>
<p>public update() {<br>
console.log(<code>AObserver: ${this.subject.getState()}</code>);<br>
}<br>
}</p>
<p>class BObserver extends Observer {<br>
// 构造方法里订阅<br>
public constructor(subject: Subject) {<br>
super();<br>
this.subject = subject;<br>
this.subject.subscribe(this);<br>
}</p>
<p>public update() {<br>
console.log(<code>BObserver: ${this.subject.getState()}</code>);<br>
}<br>
}</p>
<p>const subject = new Subject();</p>
<p>const aObserver = new AObserver(subject);<br>
const bObserver = new BObserver(subject);<br>
subject.setState(1);</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式之单例模式]]></title>
        <id>https://chasonhuang.github.io/post/she-ji-mo-shi-zhi-dan-li-mo-shi/</id>
        <link href="https://chasonhuang.github.io/post/she-ji-mo-shi-zhi-dan-li-mo-shi/">
        </link>
        <updated>2020-07-21T09:12:12.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://chasonhuang.github.io/post-images/1595470954012.jpg" alt="" loading="lazy"></figure>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://chasonhuang.github.io/post-images/1595470954012.jpg" alt="" loading="lazy"></figure>
<!-- more -->
<p>1、单例模式 Singleton<br>
简介<br>
单例就是保证一个类只有一个实例，实现的方法一般是先判断实例是否存在，如果存在直接返回，如果不存在就创建了再返回，确保了一个类只有一个实例对象，在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象</p>
<p>作用和注意事项<br>
作用</p>
<p>模块间通信<br>
在系统中某个类的对象只能存在一个<br>
保护自己的属性和方法，创建一个命名空间，防止不同的人命名变量的冲突<br>
注意事项</p>
<p>注意 this 的使用<br>
闭包容易造成内存泄漏，不需要的要清理<br>
注意 new 的成本<br>
当超过一个县线程想要获取相同资源的时候，竞争就会出现，单例模式很容易受到竞争的影响，因此如果实例一开始没有被初始化，两个现象可能就会创建两个对象而不是返回实例，因此在开发者在多线程中实现单例时，必须要保证同步<br>
类比： 如果有十个人在办公室，并且他们都需要用一台打印机，十台电脑共享了打印机（实例）通过共享了一个打印机，他们分享了相同的资源</p>
<p>个人理解<br>
开创一个命名空间，对象实例创建在命名空间中，用一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下次获取该实例的时候，直接返回之前创建的对象</p>
<p>使用场景：<br>
单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如全局缓存、浏览器的window对象。在js开发中，单例模式的用途同样非常广泛。试想一下，当我们<br>
单击登录按钮的时候，页面中会出现一个登录框，而这个浮窗是唯一的，无论单击多少次登录按钮，这个浮窗只会被创建一次。因此这个登录浮窗就适合用单例模式。<br>
总结一下它的使用场景：<br>
　　1、可以用它来划分命名空间<br>
2、借助单例模式，可以把代码组织的更为一致，方便阅读与维护</p>
<p>// class Singleton {<br>
// private static instance: Singleton</p>
<p>// private constructor () {}</p>
<p>// static getInstance (): Singleton {<br>
// if (!Singleton.instance) {<br>
// Singleton.instance = new Singleton()<br>
// }<br>
// return this.instance<br>
// }<br>
// }</p>
<p>// const singleton1 = Singleton.getInstance()<br>
// const singleton2 = Singleton.getInstance()<br>
// console.log(singleton1 === singleton2) // true</p>
<p>class Singleton {<br>
private constructor(name: string, age: number) {<br>
this.name = name;<br>
this.age = age;<br>
}</p>
<p>private static instance: Singleton;</p>
<p>public name: string;<br>
public age: number;</p>
<p>static getInstance(name: string, age: number): Singleton {<br>
if (!this.instance) {<br>
this.instance = new Singleton(name, age);<br>
}<br>
return this.instance;<br>
}<br>
}</p>
<p>const singleton1 = Singleton.getInstance(&quot;Mary&quot;, 20);<br>
const singleton2 = Singleton.getInstance(&quot;Jack&quot;, 20);<br>
console.log(singleton1, singleton2);<br>
// Singleton { name: 'Mary', age: 20 } Singleton { name: 'Mary', age: 20 }</p>
]]></content>
    </entry>
</feed>